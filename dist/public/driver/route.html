<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Route Map - Fleetillo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #map {
            width: 100vw;
            height: 100vh;
        }

        /* Error overlay */
        .error-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a2e;
            color: #fff;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }

        .error-overlay.visible {
            display: flex;
        }

        .error-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .error-message {
            font-size: 18px;
            text-align: center;
            max-width: 280px;
            line-height: 1.5;
        }

        .error-retry {
            margin-top: 24px;
            padding: 12px 24px;
            background: #4a6cf7;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
        }

        .error-retry:hover {
            background: #3a5ce7;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a2e;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 999;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: #4a6cf7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div id="loading" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading route...</div>
    </div>

    <!-- Error overlay -->
    <div id="error" class="error-overlay">
        <div class="error-icon">&#128683;</div>
        <div id="error-message" class="error-message">An error occurred</div>
        <button id="retry-btn" class="error-retry" style="display: none;">Try Again</button>
    </div>

    <!-- Map container -->
    <div id="map"></div>

    <script>
        // Configuration
        const API_BASE = '/api/v1';

        // State
        let map = null;
        let markers = [];
        let routePath = null;

        // Dark theme map styles (matching routes.html)
        const mapStyles = [
            { elementType: 'geometry', stylers: [{ color: '#242f3e' }] },
            { elementType: 'labels.text.stroke', stylers: [{ color: '#242f3e' }] },
            { elementType: 'labels.text.fill', stylers: [{ color: '#746855' }] },
            { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#38414e' }] },
            { featureType: 'road', elementType: 'geometry.stroke', stylers: [{ color: '#212a37' }] },
            { featureType: 'road', elementType: 'labels.text.fill', stylers: [{ color: '#9ca5b3' }] },
            { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#17263c' }] },
            { featureType: 'water', elementType: 'labels.text.fill', stylers: [{ color: '#515c6d' }] },
        ];

        /**
         * Show error message
         */
        function showError(message, showRetry = false) {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error-message').textContent = message;
            document.getElementById('error').classList.add('visible');
            document.getElementById('retry-btn').style.display = showRetry ? 'block' : 'none';
        }

        /**
         * Hide loading
         */
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }

        /**
         * Get token or routeId from URL
         */
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                token: params.get('token'),
                routeId: params.get('routeId')  // For testing without token auth
            };
        }

        /**
         * Fetch route data from API
         */
        async function fetchRouteData(token) {
            const response = await fetch(`${API_BASE}/public/route/${token}`);
            const data = await response.json();

            if (response.status === 410) {
                throw new Error('expired');
            }

            if (!response.ok || !data.success) {
                throw new Error('invalid');
            }

            return data.data;
        }

        /**
         * Fetch route data directly by routeId (TEST MODE - bypasses token auth)
         */
        async function fetchRouteDataDirect(routeId) {
            const response = await fetch(`${API_BASE}/public/route-test/${routeId}`);
            const data = await response.json();

            if (!response.ok || !data.success) {
                throw new Error('invalid');
            }

            return data.data;
        }

        /**
         * Load Google Maps API
         */
        async function loadGoogleMaps() {
            return new Promise((resolve, reject) => {
                // Get API key from public endpoint
                fetch('/api/v1/public/maps-key')
                    .then(r => r.json())
                    .then(data => {
                        if (!data.success || !data.data?.key) {
                            reject(new Error('Maps API key not available'));
                            return;
                        }

                        const script = document.createElement('script');
                        script.src = `https://maps.googleapis.com/maps/api/js?key=${data.data.key}&libraries=geometry`;
                        script.async = true;
                        script.onload = resolve;
                        script.onerror = () => reject(new Error('Failed to load Google Maps'));
                        document.head.appendChild(script);
                    })
                    .catch(reject);
            });
        }

        /**
         * Initialize map
         */
        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 39.8283, lng: -98.5795 },
                zoom: 4,
                styles: mapStyles,
                disableDefaultUI: true,
                zoomControl: true,
                gestureHandling: 'greedy', // Enable single-finger pan on mobile
            });
        }

        /**
         * Clear map layers
         */
        function clearMap() {
            markers.forEach(m => m.setMap(null));
            markers = [];
            if (routePath) {
                routePath.setMap(null);
                routePath = null;
            }
        }

        /**
         * Render route on map
         */
        function renderRoute(routeData) {
            clearMap();

            const bounds = new google.maps.LatLngBounds();

            // Add numbered stop markers
            routeData.stops.forEach((stop) => {
                const position = { lat: stop.lat, lng: stop.lng };
                bounds.extend(position);

                const marker = new google.maps.Marker({
                    position,
                    map,
                    label: {
                        text: String(stop.sequence),
                        color: 'white',
                        fontWeight: 'bold',
                    },
                    title: `Stop ${stop.sequence}`,
                });

                markers.push(marker);
            });

            // Draw route polyline if available
            if (routeData.polyline && google.maps.geometry) {
                try {
                    const decodedPath = google.maps.geometry.encoding.decodePath(routeData.polyline);

                    routePath = new google.maps.Polyline({
                        path: decodedPath,
                        strokeColor: '#00ff00',
                        strokeWeight: 4,
                        strokeOpacity: 0.8,
                        map,
                    });

                    // Extend bounds with polyline path
                    decodedPath.forEach(point => bounds.extend(point));

                    // Add start marker (green circle)
                    if (decodedPath.length > 0) {
                        const startMarker = new google.maps.Marker({
                            position: decodedPath[0],
                            map,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 10,
                                fillColor: '#22c55e',
                                fillOpacity: 1,
                                strokeColor: '#fff',
                                strokeWeight: 2,
                            },
                            title: 'Start',
                            zIndex: 100,
                        });
                        markers.push(startMarker);

                        // Add end marker (red circle) if different from start
                        const lastPoint = decodedPath[decodedPath.length - 1];
                        const startPoint = decodedPath[0];
                        const distance = google.maps.geometry.spherical.computeDistanceBetween(startPoint, lastPoint);

                        if (distance > 100) { // More than 100m apart
                            const endMarker = new google.maps.Marker({
                                position: lastPoint,
                                map,
                                icon: {
                                    path: google.maps.SymbolPath.CIRCLE,
                                    scale: 10,
                                    fillColor: '#ef4444',
                                    fillOpacity: 1,
                                    strokeColor: '#fff',
                                    strokeWeight: 2,
                                },
                                title: 'End',
                                zIndex: 100,
                            });
                            markers.push(endMarker);
                        }
                    }
                } catch (e) {
                    console.error('Failed to decode polyline:', e);
                    // Fall back to connecting stops with lines
                    drawFallbackPath(routeData.stops);
                }
            } else if (routeData.stops.length > 1) {
                // No polyline, draw straight lines between stops
                drawFallbackPath(routeData.stops);
            }

            // Fit map to bounds
            if (markers.length > 0) {
                if (markers.length === 1) {
                    map.setCenter(markers[0].getPosition());
                    map.setZoom(14);
                } else {
                    map.fitBounds(bounds, { padding: 50 });
                }
            }
        }

        /**
         * Draw fallback path when no polyline available
         */
        function drawFallbackPath(stops) {
            const pathCoords = stops.map(s => ({ lat: s.lat, lng: s.lng }));
            routePath = new google.maps.Polyline({
                path: pathCoords,
                strokeColor: '#00ff00',
                strokeWeight: 3,
                strokeOpacity: 0.6,
                geodesic: true,
                map,
            });
        }

        /**
         * Main initialization
         */
        async function init() {
            try {
                // Get token or routeId from URL
                const { token, routeId } = getUrlParams();

                if (!token && !routeId) {
                    showError('Invalid route link');
                    return;
                }

                // Fetch route data first (fail fast if invalid)
                let routeData;
                try {
                    if (routeId) {
                        // TEST MODE: Direct routeId access (bypasses token auth)
                        console.log('[TEST MODE] Fetching route directly by routeId:', routeId);
                        routeData = await fetchRouteDataDirect(routeId);
                    } else {
                        // Normal mode: token-based access
                        routeData = await fetchRouteData(token);
                    }
                } catch (e) {
                    if (e.message === 'expired') {
                        showError('This route link has expired');
                    } else {
                        showError('Invalid route link');
                    }
                    return;
                }

                // Load Google Maps
                try {
                    await loadGoogleMaps();
                } catch (e) {
                    console.error('Google Maps load error:', e);
                    showError('Unable to load map. Please try again.', true);
                    return;
                }

                // Initialize and render
                initMap();
                renderRoute(routeData);
                hideLoading();

            } catch (e) {
                console.error('Initialization error:', e);
                showError('Unable to load route. Please try again.', true);
            }
        }

        // Retry button handler
        document.getElementById('retry-btn').addEventListener('click', () => {
            document.getElementById('error').classList.remove('visible');
            document.getElementById('loading').classList.remove('hidden');
            init();
        });

        // Start initialization
        init();
    </script>
</body>
</html>
